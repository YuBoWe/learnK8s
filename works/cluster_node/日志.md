## 202602111915
排查proxySQL，遇到错误
主要原因是部署的时候忘记在mysql主节点上创建monitor用户，导致proxySQL一直获取不到mysql-0的信息
排查思路
__先查看pod的日志信息__
```sh
kubectl logs -n ops proxySQL-xxx
```
> 错误日志
```
2026-02-11 10:13:52 MySQL_Monitor.cpp:1387:monitor_connect_thread(): [ERROR] Server mysql-0.mysql-headless:3306 is returning "Access denied" for monitoring user
```
__分析__
这个是proxySQL在读写分离时需要额外创建monitor用户来连接主节点，获取主节点状态
在 ProxySQL 中，连接过程分为两个层面：
- 管理面（Monitor）：ProxySQL 用 monitor 用户去后端“探路”，检查谁是主库、谁是只读。
- 数据面（Django）：Django 用 root 账号连接 ProxySQL，ProxySQL 再拿着 root 账号去敲后端的门。

__解决__
在mysql-0上创建monitor用户，密码默认为monitor
```sql
CREATE USER 'monitor'@'%' IDENTIFIED WITH 'mysql_native_password' BY 'monitor';
GRANT REPLICATION CLIENT, USAGE ON *.* TO 'monitor'@'%';

-- SHOW VARIABLES LIKE 'read_only';检查主库是否被设置成了只读（这会导致 10 号组失效）
-- 如果显示 ON，请执行 SET GLOBAL read_only = OFF;
SHOW VARIABLES LIKE 'read_only';

FLUSH PRIVILEGES;
```

__验证__
在proxySQL上验证
```sql
-- 确认状态
SELECT hostgroup_id, hostname, status FROM runtime_mysql_servers;

-- 如果还是SHUNNED，查看原因
SELECT * FROM monitor.mysql_server_connect_log WHERE hostname='mysql-0.mysql-headless' ORDER BY time_start_us DESC LIMIT 3;

-- 手动把状态改回 ONLINE（给它一个机会）
UPDATE mysql_servers SET status='ONLINE';
LOAD MYSQL SERVERS TO RUNTIME;

-- 强制重新检查只读状态和变量
LOAD MYSQL VARIABLES TO RUNTIME;

-- 再次确认状态，为ONLINE就是正常了
SELECT hostgroup_id, hostname, status FROM runtime_mysql_servers;
```
